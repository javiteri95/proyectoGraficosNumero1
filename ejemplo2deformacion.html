<!DOCTYPE html>
<script src="lib/jquery-3.2.1.min.js"></script>
<script src='lib/three.js'></script>
<script src="lib/OrbitControls.js"></script>
<body style='margin: 0px; background-color: #bbbbbb; overflow: hidden;'><script>
// Se necesitan 3 cosas esenciales: un escenario (scene), una c√°mara (camera) y un renderizador (renderer)
var scene, renderer, camera , cube2;
const constantesDeformacion = [0.2,0.1 , 0.3,0.4,0.5,0.2];

// Si deseamos generar luz, necesitaremos un tipo de luz. Ej: spotLight
// Para poder visualizar al area del cono de luz, podemos usar un 'lightHelper'
var spotLight, lightHelper;
function init () {

	scene = new THREE.Scene();

	renderer = new THREE.WebGLRenderer();
	renderer.setPixelRatio(window.devicePixelRatio);
	renderer.setSize(window.innerWidth, window.innerHeight);
	renderer.setClearColor(0x000000, 1);
	document.body.appendChild( renderer.domElement );
	renderer.shadowMap.enabled = true;
	renderer.shadowMap.type = THREE.PCFSoftShadowMap;
	renderer.gammaInput = true;
	renderer.gammaOutput = true;


	camera = new THREE.PerspectiveCamera(35, window.innerWidth/window.innerHeight, 0.1, 1000);
	camera.position.set(-75, 70, 5);
	camera.lookAt(scene.position);


	var controls = new THREE.OrbitControls(camera, renderer.domElement);
	controls.addEventListener('change', render);
	controls.minDistance = 20;
	controls.maxDistance = 500;
	controls.enablePan = false;

	spotLight = new THREE.SpotLight( 0xffffff, 1 );
	spotLight.position.set(-25, 30, 5);

	spotLight.penumbra = 0.05;
	spotLight.decay = 2;
	spotLight.distance = 200;
	spotLight.castShadow = true;
	spotLight.shadow.mapSize.width = 1024;
	spotLight.shadow.mapSize.height = 1024;
	spotLight.shadow.camera.near = 10;
	spotLight.shadow.camera.far = 200;

	scene.add(spotLight);

	lightHelper = new THREE.SpotLightHelper( spotLight );
	scene.add( lightHelper );

	var ambient = new THREE.AmbientLight( 0xffffff, 0.025 );
	scene.add( ambient );

	var geometry = new THREE.BoxGeometry(4, 4, 4);
	var material = new THREE.MeshPhongMaterial( {color: 0x00ff00, dithering: true} );
	var cube = new THREE.Mesh(geometry, material);
	cube.position.set(-2, 2, 0);
	cube.castShadow = true;
	scene.add(cube);



	var geometry2 = new THREE.BoxGeometry(4, 4, 4);
	var material2 = new THREE.MeshPhongMaterial( {color: 0x00ff00, dithering: true} );


	cube2 = new THREE.Mesh(geometry2, material2);

	cube2.position.set(-10, 2, 0);
	cube2.castShadow = true;
	/*************************************************
	aqui se aplica la deformacion

	******************************************************/
	deform(cube2, constantesDeformacion);
	scene.add(cube2);

	
	cube3 = cube2.clone();
	cube3.position.set(-20, 2,0);
	scene.add(cube3);
	



	var planeGeometry = new THREE.PlaneGeometry(2000, 2000);
	var planeMaterial = new THREE.MeshPhongMaterial({color : 0xcccccc, dithering: true});
	var plane = new THREE.Mesh(planeGeometry,planeMaterial);
	plane.rotation.x = -0.5 * Math.PI;
	plane.position.set(15, 0, 0);
	plane.receiveShadow = true;
	scene.add(plane);
	

	var grid = new THREE.GridHelper( 200, 10 ,0xffffff, 0xffffff );
	scene.add( grid );

	for (var i = 0; i < scene.children.length; i++) {
		console.log(i);

	}
	window.addEventListener('resize', onResize, false);
}

function render() {
	lightHelper.update();
	var constantes = [];
	// shadowCameraHelper.update();
	/* INTENTO DE ANIMARLO
	for (i = 1 ; i<7 ; i ++){
		constantes.push(Math.floor((Math.random() * 10) + 1))
	}
	deform(cube2,constantes);
	*/
	requestAnimationFrame( render );
	renderer.render(scene, camera);
}

function onResize() {
	camera.aspect = window.innerWidth / window.innerHeight;
	camera.updateProjectionMatrix();
	renderer.setSize( window.innerWidth, window.innerHeight );
}
/*




/**********************************************************************************
							 Funcion deformacion 




//basicamnete genero una matriz de 4*4 y modifico la figura usanodlo aplicado en clases
************************************************************************************/
function deform(figura, constantes){
	var matrix = new THREE.Matrix4();
	//constantes = [Syx, Szx , Sxy , Szy , Sxz , Syz]

	matrix.set( 1 , constantes[0], constantes[1], 0 ,
							constantes[2] , 1 , constantes[3] , 0,
							constantes[4] , constantes[5] , 1 , 0 , 
							0 , 0, 0 , 1);


	figura.geometry.applyMatrix( matrix);
}

init();
render();


</script></body>